# -*- coding: utf-8 -*-
"""Dicoding_MLMahir_Proyek2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RbeXrp33eZC-6l9iAmkV8rXNv3WPPK4s

Library
"""

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import matplotlib.pyplot as plt
import seaborn as sns

"""#Data Understanding"""

links = pd.read_csv('links.csv')
movies = pd.read_csv('movies.csv')
ratings = pd.read_csv('ratings.csv')
tags = pd.read_csv('tags.csv')

print('Jumlah data link movie : ', len(links.movieId.unique()))
print('Jumlah data movie : ', len(movies.movieId.unique()))
print('Jumlah data ratings dari user : ', len(ratings.userId.unique()))
print('Jumlah data ratings dari user : ', len(ratings.movieId.unique()))
print('Jumlah data : ', len(tags.movieId.unique()))

"""#Univariate Exploratory Data Analysis
Variabel-variabel pada movie-recommendation-data adalah sebagai berikut :

Link: adalah daftar tautan film tersebut.   
Film: adalah daftar film yang tersedia.   
Rating: adalah daftar penilaian yang diberikan oleh pengguna untuk film-film tersebut.  
Tag: adalah daftar kata kunci untuk film-film tersebut.

Semua variable ini akan digunakan dalam pembuatan sistem rekomendasi content-based filtering.
"""

links.info()

links.head()

movies.info()

movies.head()

ratings.info()

ratings.head()

tags.info()

tags.head()

ratings.describe()

"""berdasarkan deskripsi ratings diatas didapatkan informasi bahwa nilai minimum rating adalah 0,5 dan maksimal 5 sehingga skala ratingnya 0,5-5"""

# Distribusi nilai rating
plt.figure(figsize=(10, 6))
sns.histplot(ratings['rating'], bins=10, kde=True, color='skyblue')
plt.title('Distribusi Nilai Rating')
plt.xlabel('Rating')
plt.ylabel('Frekuensi')
plt.show()

"""berdasarkan informasi dari diagram bar diatas menunjukan bahwa ratings terdistribusi dengan baik dalam skala 0,5-5 dan rating paling banyak diberikan pada kisaran 4"""

# Jumlah film berdasarkan genre
genre_count = movies['genres'].str.split('|').explode().value_counts()
plt.figure(figsize=(12, 6))
genre_count.plot(kind='bar', color='lightcoral')
plt.title('Jumlah Film Berdasarkan Genre')
plt.xlabel('Genre')
plt.ylabel('Jumlah Film')
plt.xticks(rotation=45)
plt.show()

"""berdasarkan diagram bar dari jumlah film berdasarkan genre terdapat informasi bahwa film dengan genre drama menempati posisi pertama dalam jumlah filmnya. kemudian terdapat informasi bahwa ada filmnya yang tidak memiliki genre. Hal ini dapat membuat model yang akan dibuat terganggu karena terdapat anomali pada data tersebut, maka harus dilakukan pembersihan data sebelum data di buat model.

#Multivariate Exploratory Data Analysis
"""

# Gabungkan data movies dengan data ratings
movies_ratings = pd.merge(movies, ratings, on='movieId')

# Explode genre menjadi baris baru untuk setiap genre dalam list
movies_ratings['genre_list'] = movies_ratings['genres'].str.split('|')
movies_ratings = movies_ratings.explode('genre_list')

# Buat box plot untuk distribusi nilai rating berdasarkan genre
plt.figure(figsize=(12, 6))
sns.boxplot(data=movies_ratings, x='genre_list', y='rating', palette='Set3')
plt.title('Distribusi Nilai Rating berdasarkan Genre Film')
plt.xlabel('Genre')
plt.ylabel('Nilai Rating')
plt.xticks(rotation=45)
plt.show()

"""berdasarkan diagram boxplot dihasilkan informasi bahhwa korelasi antara genre dan rating memiliki hal yang kuat, terbukti pada genre documentary dan film-noir, kedua film ini mendapati ratings yang cenderung tinggi sedangkan genre lain hampir mirip persebaran ratingsnya

#Data Processing

##Menggabungkan MovieID
Fungsi ini digunakan untuk menggabungkan semua ID film dari empat dataframe yang berbeda (links, movies, ratings, dan tags) ke dalam satu array tunggal. Kemudian, array tersebut diurutkan dan data yang sama dihapus. Tujuannya adalah untuk menciptakan daftar yang unik dari semua ID film yang terdapat dalam dataset. Hasil akhirnya adalah daftar yang berisi semua ID film yang berbeda dalam dataset tersebut
"""

# Menggabungkan seluruh movieID pada kategori movie
movie_all = np.concatenate((
    links.movieId.unique(),
    movies.movieId.unique(),
    ratings.movieId.unique(),
    tags.movieId.unique(),
))

# Mengurutkan data dan menghapus data yang sama
movie_all = np.sort(np.unique(movie_all))

print('Jumlah seluruh data movie berdasarkan movieID: ', len(movie_all))

"""## Menggabungkan userID
Fungsi ini digunakan untuk menggabungkan semua ID pengguna dari dua dataframe yang berbeda (ratings dan tags) ke dalam satu array tunggal. Kemudian, array tersebut diurutkan dan data yang sama dihapus. Tujuannya adalah untuk menciptakan daftar yang unik dari semua ID pengguna yang terdapat dalam dataset. Hasil akhirnya adalah daftar yang berisi semua ID pengguna yang berbeda dalam dataset tersebut.
"""

# Menggabungkan seluruh userId
user_all = np.concatenate((
    ratings.userId.unique(),
    tags.userId.unique(),

))

# Menghapus data yang sama kemudian mengurutkannya
user_all = np.sort(np.unique(user_all))

print('Jumlah seluruh user: ', len(user_all))

"""menggabungkan beberapa dataframe untuk menyatukan informasi tentang film dan penilaian pengguna ke dalam satu dataframe tunggal. Ini memungkinkan untuk menganalisis data penilaian film bersama dengan informasi detail tentang setiap film."""

movie_info = pd.concat([links, movies, ratings, tags])
movie = pd.merge(ratings, movie_info , on='movieId', how='left')
movie

"""berdasarkan hasil dari penggabungan dataframe didapatin hasil bahwa terdapat nilai yang hilang"""

movie.isnull().sum()

"""menghitung jumlah nilai null (nilai yang hilang) dalam setiap kolom dari dataframe movie."""

movie.groupby('movieId').sum()

"""Fungsi tersebut mengelompokkan data berdasarkan ID film (movieId) dan menjumlahkan nilai-nilai dalam setiap grup.

##Menggabungkan Data dengan Fitur Nama Movie
mendefinisikan variabel all_movie_rate dengan variabel ratings
"""

all_movie_rate = ratings
all_movie_rate

"""Menggabungkan all movie_rate dengan dataframe movies berdasarkan movieId"""

all_movie_name = pd.merge(all_movie_rate, movies[['movieId','title','genres']], on='movieId', how='left')
all_movie_name

"""Gabungkan dataframe tags dengan all_movie_name menggunakan kolom 'movieId', lalu simpan hasilnya ke dalam variabel all_movie."""

# Menggabungkan dataframe genres dengan all_movie_name dan memasukkannya ke dalam variabel all_movie
all_movie = pd.merge(all_movie_name, tags[['movieId','tag']], on='movieId', how='left')
all_movie

"""#Data Preparation

##Mengatasi missing value
"""

all_movie.isnull().sum()

"""terdapat 52549 missing value pada kolom tag, kemudian dilakukan pembersihan mengguakan fungsi dropna()"""

all_movie_clean = all_movie.dropna()
all_movie_clean

"""Jumlah data diatas berkurang banyak dari 285762 rows menjadi 233213 rows. Data dicek kembali apakah pembersihan berhasil atau tidak menggunakan fungsi isnull().sum()"""

all_movie_clean.isnull().sum()

"""Mengurutkan movie berdasarkan movieId kemudian memasukkannya ke dalam variabel fix_movie"""

fix_movie = all_movie_clean.sort_values('movieId', ascending=True)
fix_movie

"""Mengecek berapa jumlah fix_movie"""

len(fix_movie.movieId.unique())

"""Membuat variabel preparation yang berisi dataframe fix_movie kemudian mengurutkan berdasarkan movieId"""

preparation = fix_movie
preparation.sort_values('movieId')

"""Selanjutnya, gunakan data unik untuk dimasukkan ke dalam proses pemodelan. serta hapus data duplicate dengan fungsi drop_duplicates() berdasarkan movieId"""

preparation = preparation.drop_duplicates('movieId')
preparation

"""Selanjutnya, melakukan konversi data series menjadi list. Dalam hal ini, menggunakan fungsi tolist() dari library numpy. Implementasikan"""

# Mengonversi data series ‘movieId’ menjadi dalam bentuk list
movie_id = preparation['movieId'].tolist()

# Mengonversi data series ‘title’ menjadi dalam bentuk list
movie_name = preparation['title'].tolist()

# Mengonversi data series ‘genres’ menjadi dalam bentuk list
movie_genre = preparation['genres'].tolist()

print(len(movie_id))
print(len(movie_name))
print(len(movie_genre))

"""membuat dictionary untuk menentukan pasangan key-value pada data movie_id, movie_name, dan movie_genre yang telah disiapkan sebelumnya."""

# Membuat dictionary untuk data ‘movie_id’, ‘movie_name’, dan ‘movie_genre’
movie_new = pd.DataFrame({
    'id': movie_id,
    'movie_name': movie_name,
    'genre': movie_genre
})
movie_new

"""#Modeling

menggunakan TfidfVectorizer untuk menghitung nilai IDF dari kata kunci dalam kolom 'genre' dari dataframe movie_new. Kemudian, ia mengembalikan daftar kata kunci yang dihasilkan dalam bentuk array dari fitur index integer ke fitur nama.
"""

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genre
tf.fit(movie_new['genre'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

""" fit dan transformasi ke dalam bentuk matriks."""

tfidf_matrix = tf.fit_transform(movie_new['genre'])
tfidf_matrix.shape

"""menghasilkan vektor tf-idf dalam bentuk matriks, menggunakan fungsi todense()."""

tfidf_matrix.todense()

"""menghasilkan DataFrame yang berisi sampel 10 baris dan 22 kolom dari matriks TF-IDF. Setiap baris mewakili satu film dan setiap kolom mewakili satu kata kunci. Hal ini membantu dalam memvisualisasikan representasi TF-IDF dari beberapa kata kunci secara acak untuk beberapa film."""

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=movie_new.movie_name
).sample(22, axis=1).sample(10, axis=0)

"""menggunakan fungsi cosine_similarity dari scikit-learn untuk menghitung kemiripan kosinus antara setiap pasang vektor fitur dalam tfidf_matrix. Hasilnya adalah matriks kemiripan kosinus yang menunjukkan seberapa mirip setiap pasang dokumen berdasarkan representasi TF-IDF mereka."""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""membuat DataFrame cosine_sim_df dari matriks kemiripan kosinus antara setiap pasang film. Indeks baris dan kolomnya diambil dari kolom 'movie_name' dari dataframe movie_new. Kemudian menampilkan sampel acak dari DataFrame tersebut untuk memudahkan visualisasi."""

cosine_sim_df = pd.DataFrame(cosine_sim, index=movie_new['movie_name'], columns=movie_new['movie_name'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""#Hasil Akhir

Fungsi movie_recommendations digunakan untuk merekomendasikan film-film yang mirip dengan film tertentu berdasarkan matriks kemiripan kosinus similarity_data. Berikut adalah penjelasan singkat dari fungsi tersebut:

nama_movie: Parameter yang menentukan film yang ingin dicari rekomendasinya.  
similarity_data: Matriks kemiripan kosinus antara setiap pasang film. Defaultnya adalah cosine_sim_df.  
items: DataFrame yang berisi informasi tentang film-film, seperti judul dan genre. Defaultnya adalah movie_new[['movie_name', 'genre']].  
k: Parameter yang menentukan jumlah film yang direkomendasikan. Defaultnya adalah 5.
"""

def movie_recommendations(nama_movie, similarity_data=cosine_sim_df, items=movie_new[['movie_name', 'genre']], k=5):


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,nama_movie].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop nama_movie agar nama movie yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_movie, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""menggunakan fungsi movies_recommendations dengan judul film 'Sense and Sensibility (1995)'"""

movie_new[movie_new.movie_name.eq('Sense and Sensibility (1995)')]

"""Berdasarkan hasil di atas, terlihat bahwa pengguna menyukai film berjudul 'Sense and Sensibility (1995)' dengan genre Drama dan Romance. Kita ingin mencari rekomendasi film yang mirip dengan 'Sense and Sensibility (1995)'."""

movie_recommendations('Sense and Sensibility (1995)')

"""dari hasil fungsi diatas menampilkan top 5 rekomendasi film berdasarkan genre yang di input user, dari kelima film yang ditampilkan semuanya memiliki genre yang sama, hal ini membuktikan bahwa sistem rekomendasi content-based yang dibuat mendapatkan hasil precission 5/5 atau 100%"""